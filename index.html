<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Wiggle Ball League</title>

<style>
	body {
		font-family: Arial;
		background: #111;
		color: white;
		padding: 15px;
	}

	button {
		padding: 10px;
		margin: 5px;
		font-size: 15px;
		cursor: pointer;
	}

	.card {
		background: #222;
		padding: 15px;
		margin-top: 10px;
		border-radius: 10px;
	}

	.card.disabled {
		opacity: 0.4;
		pointer-events: none;
	}

	input, select {
		padding: 8px;
		margin: 5px;
	}

	.hidden {
		display: none;
	}

	.menu-button {
		width: 100%;
		padding: 20px;
		font-size: 18px;
		margin: 10px 0;
		background: #333;
		color: white;
		border: 2px solid #555;
		border-radius: 10px;
		cursor: pointer;
	}

	.menu-button:hover {
		background: #444;
		border-color: #777;
	}

	.back-button {
		background: #555;
		margin-bottom: 15px;
	}

	.end-game-button {
		background: #a44;
		color: white;
	}

	.undo-button {
		background: #aa6;
		color: white;
		font-weight: bold;
		width: 100%;
		padding: 15px;
		margin: 10px 0;
	}

	.scoreboard {
		display: flex;
		justify-content: space-around;
		font-size: 18px;
		margin: 10px 0;
	}

	.scoreboard div {
		text-align: center;
	}

	.diamond {
		display: grid;
		grid-template-columns: 1fr 1fr 1fr;
		grid-template-rows: 1fr 1fr 1fr;
		gap: 5px;
		max-width: 200px;
		margin: 0 auto;
	}

	.diamond .base {
		width: 50px;
		height: 50px;
		background: #444;
		border: 2px solid #666;
		border-radius: 8px;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 11px;
		text-align: center;
	}

	.base.occupied {
		background: #4a4;
		border-color: #6c6;
	}

	.base.ghostie {
		background: #66a;
		border-color: #88c;
	}

	.diamond .second {
		grid-column: 2;
		grid-row: 1;
	}

	.diamond .third {
		grid-column: 1;
		grid-row: 2;
	}

	.diamond .first {
		grid-column: 3;
		grid-row: 2;
	}

	.diamond .home {
		grid-column: 2;
		grid-row: 3;
		background: #664;
		border-color: #886;
	}

	.stats-table {
		width: 100%;
		border-collapse: collapse;
		margin-top: 10px;
	}

	.stats-table th, .stats-table td {
		padding: 8px;
		text-align: left;
		border-bottom: 1px solid #444;
	}

	.stats-table th {
		background: #333;
	}

	.winner-banner {
		background: #4a4;
		padding: 20px;
		text-align: center;
		border-radius: 10px;
		font-size: 24px;
		margin-bottom: 15px;
	}

	.section-header {
		background: #333;
		padding: 10px;
		border-radius: 8px;
		margin-bottom: 10px;
		font-weight: bold;
		font-size: 18px;
	}

	.notification {
		background: #444;
		padding: 10px;
		border-radius: 5px;
		margin: 10px 0;
		text-align: center;
		color: #6c6;
	}

	/* ================================
	   ‚úÖ ACCESS GATE (login + league code)
	==================================*/
	.gate {
		position: fixed;
		top: 0; left: 0; right: 0; bottom: 0;
		background: rgba(0,0,0,0.88);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 9999;
		padding: 15px;
	}
	.gate.hidden { display: none; }
	.gate-panel {
		width: min(520px, 100%);
		background: #1c1c1c;
		border: 1px solid #333;
		border-radius: 14px;
		padding: 16px;
		box-shadow: 0 10px 40px rgba(0,0,0,0.55);
	}
	.gate-panel h2 { margin: 6px 0 10px 0; }
	.gate-note { color:#aaa; font-size: 13px; line-height: 1.35; }
	.gate-row { margin-top: 10px; }
	.gate-row input { width: 100%; box-sizing: border-box; }
	.gate-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
	.gate-actions button { flex: 1; }
	.small-link { background: transparent; border: 1px solid #555; color: #ddd; }
	.locked-badge {
		display: inline-block;
		padding: 6px 10px;
		border-radius: 999px;
		background: #333;
		border: 1px solid #555;
		font-size: 12px;
		color: #ddd;
		margin-top: 8px;
	}

</style>

</head>

<body>


<!-- ‚úÖ ACCESS GATE: blocks app until login + league code -->
<div id="accessGate" class="gate hidden">
	<div class="gate-panel">
		<h2 id="gateTitle">üîí League Access Required</h2>
		<p class="gate-note" id="gateMsg">
			To use this app, you must log in and enter the league code.
		</p>

		<div class="card" style="margin-top:10px;">
			<div id="gateStepLogin">
				<h3 style="margin-top:0;">1) Log in</h3>
				<div class="gate-row">
					<input id="gateLoginEmail" placeholder="Email for login" />
				</div>

				<div class="gate-row hidden" id="gateNameRow">
					<input id="gateNameInput" placeholder="Your name (required)" />
				</div>

				<div class="gate-actions">
					<button class="menu-button" onclick="sendLoginLinkFromGate()">üìß Send Login Link</button>
				</div>
				<p class="gate-note" style="margin:8px 0 0 0;">
					After you click the email link, you‚Äôll return here automatically.
				</p>
			</div>

			<div id="gateStepCode" class="hidden">
				<h3 style="margin-top:0;">2) Enter League Code</h3>
				<div class="gate-row">
					<input id="gateLeagueCode" placeholder="League code" />
				</div>
				<div class="gate-actions">
					<button class="menu-button" onclick="submitLeagueCode()">‚úÖ Unlock App</button>
					<button class="small-link" onclick="logout()">Log Out</button>
				</div>
				<p class="gate-note" style="margin:8px 0 0 0;">
					This code is required to protect your league.
				</p>
			</div>

			<div id="gateStepDone" class="hidden">
				<h3 style="margin-top:0;">‚úÖ You‚Äôre in!</h3>
				<p class="gate-note">Welcome, <span id="gateWelcomeName"></span>.</p>
				<div class="gate-actions">
					<button class="menu-button" onclick="closeGate()">Continue</button>
				</div>
			</div>
		</div>

		<div class="locked-badge" id="gateStatusBadge">Status: Locked</div>
	</div>
</div>



<!-- MAIN MENU -->
<div id="mainMenu">
	<h1>‚öΩ Wiffle Ball League</h1>
	
	<div class="card">
		<h3>Welcome to Wiffle Ball!</h3>
		<p>Manage your league teams and play games</p>
		
		<button class="menu-button" onclick="showTeamConfig()">
			‚öôÔ∏è Configure Teams
		</button>
		
		<button class="menu-button" onclick="showGameSetup()">
			üéÆ Start a Game
		</button>



		<button class="menu-button" onclick="showSeasonStats()">
			üìä Season Stats
		</button>

		<button class="menu-button" onclick="showSchedule()">
  üìÖ Schedule
</button>
		

<div id="mainLoginBlock">
  <input id="loginEmail" placeholder="Email for login" />
  <button id="mainSendLinkBtn" class="menu-button" onclick="sendLoginLink()">üìß Send Login Link</button>
</div>

<div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px;">
  <button id="showActiveUsersBtn" class="small-link hidden" onclick="showActiveUsers()">üë• Logged In</button>
  <button id="mainLogoutBtn" class="menu-button hidden" onclick="logout()">Log Out</button>
</div>

</div>
</div>

<!-- ‚úÖ ADD THIS BUTTON on the MAIN MENU (inside the mainMenu card with the other menu buttons) -->



<!-- ‚úÖ ADD THIS NEW SCREEN anywhere with the other screens (recommended: below Season Stats Screen) -->
<div id="scheduleScreen" class="hidden">
	<button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>

	<h2>üìÖ Season Schedule</h2>

	<div class="card">
		<p style="color:#aaa; margin-top:0;">
			6 game days ‚Ä¢ 4 teams ‚Ä¢ everyone plays each other twice
		</p>
	</div>

	<div id="scheduleContainer"></div>
</div>


<!-- ACTIVE USERS SCREEN -->
<div id="activeUsersScreen" class="hidden">
  <button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>
  <h2>üë• Currently Logged In</h2>
  <div class="card">
    <p style="color:#aaa; margin-top:0;">
      Shows players who opened the app recently (last 5 minutes).
    </p>
    <div id="activeUsersContainer" style="margin-top:10px;"></div>
  </div>
</div>

</div>

<!-- TEAM CONFIGURATION SCREEN -->
<div id="teamConfigScreen" class="hidden">
	<button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>
	
	<h2>‚öôÔ∏è Team Configuration</h2>

	<div class="card">
		<h3>Add Team</h3>
		<input id="teamName" placeholder="Team Name">
		<button onclick="addTeam()">Add Team</button>
	</div>

	<div class="card">
		<h3>Add Player (Max 2 Per Team)</h3>
		<select id="teamSelect"></select>
		<input id="playerName" placeholder="Player Name">
		<button onclick="addPlayer()">Add Player</button>
	</div>

	<div class="card">
		<h3>League Teams</h3>
		<div id="teamList"></div>
	</div>
</div>

<!-- GAME SETUP SCREEN -->
<div id="gameSetupScreen" class="hidden">
	<button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>
	
	<h2>üéÆ Start a Game</h2>

	<div class="card">
		<h3>Select Teams</h3>
		<p>Team 1:</p>
		<select id="team1Select"></select>
		
		<p>Team 2:</p>
		<select id="team2Select"></select>
		
		<button class="menu-button" onclick="startGame()">Start Game</button>
	</div>
</div>

<!-- GAME SCREEN -->
<div id="gameScreen" class="hidden">
	<button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>
	<button class="end-game-button" onclick="endGameEarly()">End Game Early</button>

	<div class="card">
		<div class="scoreboard">
			<div>
				<strong id="team1Name"></strong><br>
				<span id="team1Score" style="font-size: 24px;">0</span>
			</div>
			<div>
				<strong id="team2Name"></strong><br>
				<span id="team2Score" style="font-size: 24px;">0</span>
			</div>
		</div>
	</div>

	<div id="notification" class="notification hidden"></div>

	<div class="card">
		<button class="undo-button" id="undoButton" onclick="undoLastAction()" disabled>‚Ü∂ Undo Last Action</button>
	</div>

	<!-- BATTING SECTION -->
	<div id="battingSection">
		<div class="section-header">‚öæ BATTING</div>

		<div class="card">
			<h3 id="inningText"></h3>
			<p id="outsText"></p>
			<h2 id="batterText"></h2>
		</div>

		<div class="card">
			<h3>Bases</h3>
			<div class="diamond">
				<div class="base second" id="base2">2nd</div>
				<div class="base third" id="base3">3rd</div>
				<div class="base first" id="base1">1st</div>
				<div class="base home">Home</div>
			</div>
		</div>

		<div class="card">
			<h3>Record Batting Result</h3>
			<button onclick="recordBattingResult('single')">Single</button>
			<button onclick="recordBattingResult('double')">Double</button>
			<button onclick="recordBattingResult('triple')">Triple</button>
			<button onclick="recordBattingResult('HR')">Home Run</button>
			<button onclick="recordBattingResult('walk')">Walk</button>
			<button onclick="recordBattingResult('K')">Strikeout</button>
			<button onclick="recordBattingResult('out')">Out</button>
		</div>
	</div>

	<div class="card">
		<h3>Manual Base Controls</h3>
		<p style="font-size: 13px; color:#aaa;">
			Use for steals, pickoffs, or corrections. Does not change hit/AB stats.
		</p>
	
		<div>
			<button onclick="manualMove('first','second')">1st ‚Üí 2nd</button>
			<button onclick="manualMove('second','third')">2nd ‚Üí 3rd</button>
			<button onclick="manualScoreFromThird()">3rd ‚Üí Home (Score)</button>
		</div>
	
		<div>
			<button onclick="manualMove('second','first')">2nd ‚Üí 1st</button>
			<button onclick="manualMove('third','second')">3rd ‚Üí 2nd</button>
		</div>
	
		<div style="margin-top:8px;">
			<button onclick="clearBases()" style="background:#555;color:white;">Clear Bases</button>
		</div>
	</div>

	<div style="margin-top:10px;">
		<button onclick="showOutPicker()" style="background:#a66;color:white;">
	    Runner Thrown Out
	  </button>
	
		<div id="outPicker" class="hidden" style="margin-top:10px;">
			<p style="margin:6px 0;">Which runner got thrown out?</p>
			<select id="outBaseSelect">
	      <option value="first">Runner on 1st</option>
	      <option value="second">Runner on 2nd</option>
	      <option value="third">Runner on 3rd</option>
	    </select>
	
			<button onclick="confirmRunnerOut()">Confirm Out</button>
			<button onclick="cancelRunnerOut()">Cancel</button>
		</div>
	</div>

	<!-- PITCHING SECTION -->
	<div id="pitchingSection" class="disabled">
		<div class="section-header">ü•é PITCHING</div>

		<div class="card">
			<h3>Select Pitcher</h3>
			<select id="pitcherSelect" onchange="updatePitcherDisplay()"></select>
			<p id="pitcherText"></p>
		</div>

		<div class="card">
			<h3>Record Pitching Result</h3>
			<p style="font-size: 14px; color: #aaa;">Batting result recorded. Was there a fielding error?</p>

	<button onclick="showErrorPicker()">Error (Last Play)</button>
		
		<div id="errorPicker" class="hidden" style="margin-top:10px;">
			<p style="margin:6px 0;">Who made the error?</p>
			<select id="errorPlayerSelect"></select>
			<button onclick="confirmError()">Confirm Error</button>
			<button onclick="cancelError()">Cancel</button>
		</div>
		</div>
	</div>

</div>

<!-- GAME OVER SCREEN -->
<div id="gameOverScreen" class="hidden">
	<button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>
	
	<div id="winnerBanner" class="winner-banner"></div>

	<div class="card">
		<h3>Final Score</h3>
		<div class="scoreboard">
			<div>
				<strong id="finalTeam1Name"></strong><br>
				<span id="finalTeam1Score" style="font-size: 24px;">0</span>
			</div>
			<div>
				<strong id="finalTeam2Name"></strong><br>
				<span id="finalTeam2Score" style="font-size: 24px;">0</span>
			</div>
		</div>
	</div>

	<div id="statsContainer"></div>
</div>

<!-- SEASON STATS SCREEN -->
<div id="seasonStatsScreen" class="hidden">
	<button class="back-button" onclick="showMainMenu()">‚Üê Back to Main Menu</button>
	
	<h2>üìä Season Statistics</h2>

	<div id="seasonStatsContainer"></div>

	<div class="card">
		<button onclick="resetSeason()" style="background: #a44; color: white;">Reset Season Data</button>
	</div>
</div>
<!-- SCHEDULE SCREEN -->

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>

const SUPABASE_URL = "https://hunqtklytyorvmztgpqt.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh1bnF0a2x5dHlvcnZtenRncHF0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA4NDc0MzcsImV4cCI6MjA4NjQyMzQzN30.ONu6M24_vhaeN-YlqKr-mtNjRuLLMfMeMfdTDMUllfA";


const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* ================================
   ‚úÖ LEAGUE ACCESS SETTINGS
   - Change LEAGUE_CODE to your secret
==================================*/
const LEAGUE_CODE = "6767"; // <-- IMPORTANT: change this

const LS_NAME_KEY = "wbl_userName";
const LS_EMAIL_KEY = "wbl_userEmail";
const LS_LEAGUE_OK_KEY = "wbl_leagueOk";

/* ================================
   ‚úÖ ACCESS GATE HELPERS
==================================*/
function getStoredName() {
  return (localStorage.getItem(LS_NAME_KEY) || "").trim();
}
function setStoredName(name) {
  localStorage.setItem(LS_NAME_KEY, (name || "").trim());
}
function getStoredEmail() {
  return (localStorage.getItem(LS_EMAIL_KEY) || "").trim();
}
function setStoredEmail(email) {
  localStorage.setItem(LS_EMAIL_KEY, (email || "").trim());
}
function isLeagueUnlocked() {
  return localStorage.getItem(LS_LEAGUE_OK_KEY) === "true";
}
function setLeagueUnlocked(v) {
  localStorage.setItem(LS_LEAGUE_OK_KEY, v ? "true" : "false");
}


/* ================================
   ‚úÖ ACTIVE USERS (who's logged in)
   - Uses Supabase table: active_users
==================================*/
let presenceInterval = null;
let presenceUserId = null;

async function startPresence() {
  if (!isLeagueUnlocked()) return; // only after correct league code
  const { data } = await supabaseClient.auth.getSession();
  const session = data?.session;
  if (!session) return;

  const userId = session.user.id;
  const name = (getStoredName() || "Player").trim();

  presenceUserId = userId;

  // upsert on load
  try {
    await supabaseClient.from("active_users").upsert({
      user_id: userId,
      name,
      last_seen: new Date().toISOString()
    });
  } catch (e) {
    console.log("active_users upsert failed:", e);
  }

  // heartbeat every 60s
  if (presenceInterval) clearInterval(presenceInterval);
  presenceInterval = setInterval(async () => {
    if (!presenceUserId) return;
    try {
      await supabaseClient.from("active_users").upsert({
        user_id: presenceUserId,
        name,
        last_seen: new Date().toISOString()
      });
    } catch (e) {}
  }, 60000);

  // best-effort cleanup
  window.addEventListener("beforeunload", () => {
    try {
      if (presenceUserId) supabaseClient.from("active_users").delete().eq("user_id", presenceUserId);
    } catch (e) {}
  });
}

async function stopPresence() {
  if (presenceInterval) clearInterval(presenceInterval);
  presenceInterval = null;

  try {
    if (presenceUserId) await supabaseClient.from("active_users").delete().eq("user_id", presenceUserId);
  } catch (e) {}

  presenceUserId = null;
}

async function updateAuthUI() {
  const { data } = await supabaseClient.auth.getSession();
  const loggedIn = !!data?.session;
  const unlocked = loggedIn && isLeagueUnlocked() && !!getStoredName();

  const mainLoginBlock = document.getElementById("mainLoginBlock");
  const logoutBtn = document.getElementById("mainLogoutBtn");
  const activeBtn = document.getElementById("showActiveUsersBtn");

  if (mainLoginBlock) mainLoginBlock.classList.toggle("hidden", unlocked);
  if (logoutBtn) logoutBtn.classList.toggle("hidden", !loggedIn);
  if (activeBtn) activeBtn.classList.toggle("hidden", !unlocked);

  if (unlocked) startPresence();
  else stopPresence();
}

async function showActiveUsers() {
  if (!(await requireLogin())) return;
  hideAllScreens();
  document.getElementById("activeUsersScreen").classList.remove("hidden");
  await loadActiveUsers();
}

async function loadActiveUsers() {
  const box = document.getElementById("activeUsersContainer");
  if (!box) return;

  box.innerHTML = '<p style="color:#aaa;">Loading...</p>';

  const cutoff = new Date(Date.now() - 5 * 60 * 1000).toISOString();

  const { data, error } = await supabaseClient
    .from("active_users")
    .select("name,last_seen")
    .gte("last_seen", cutoff)
    .order("name", { ascending: true });

  if (error) {
    box.innerHTML = '<p style="color:#f88;">Could not load active users (table missing or permissions).</p>';
    console.log(error);
    return;
  }

  const names = (data || [])
    .map(r => (r.name || "").trim())
    .filter(Boolean);

  if (!names.length) {
    box.innerHTML = '<p style="color:#aaa;">No one active right now.</p>';
    return;
  }

  box.innerHTML = names.map(n => `<div style="padding:8px;border-bottom:1px solid #333;">${n}</div>`).join("");
}


function showGate(step, msg) {
  const gate = document.getElementById("accessGate");
  gate.classList.remove("hidden");

  document.getElementById("gateStepLogin").classList.add("hidden");
  document.getElementById("gateStepCode").classList.add("hidden");
  document.getElementById("gateStepDone").classList.add("hidden");

  const badge = document.getElementById("gateStatusBadge");
  if (msg) document.getElementById("gateMsg").innerText = msg;

  if (step === "login") {
    document.getElementById("gateTitle").innerText = "üîí Login Required";
    document.getElementById("gateStepLogin").classList.remove("hidden");
    badge.innerText = "Status: Locked (not logged in)";
  } else if (step === "code") {
    document.getElementById("gateTitle").innerText = "üîí League Code Required";
    document.getElementById("gateStepCode").classList.remove("hidden");
    badge.innerText = "Status: Locked (league code not entered)";
  } else if (step === "done") {
    document.getElementById("gateTitle").innerText = "‚úÖ Access Granted";
    document.getElementById("gateWelcomeName").innerText = getStoredName() || "Player";
    document.getElementById("gateStepDone").classList.remove("hidden");
    badge.innerText = "Status: Unlocked";
  } else {
    // fallback
    document.getElementById("gateTitle").innerText = "üîí League Access Required";
    document.getElementById("gateStepLogin").classList.remove("hidden");
    badge.innerText = "Status: Locked";
  }

  // Prefill gate email/name from localStorage
  const e = getStoredEmail();
  if (e) document.getElementById("gateLoginEmail").value = e;
  const n = getStoredName();
  if (n) document.getElementById("gateNameInput").value = n;
}

function closeGate() {
  document.getElementById("accessGate").classList.add("hidden");
  showMainMenu();
}

function validateEmailBasic(email) {
  // simple check only
  return /.+@.+\..+/.test(email);
}

function maybeShowNameBox(email) {
  const row = document.getElementById("gateNameRow");
  // show name input after email is entered (your request)
  if (validateEmailBasic(email) && !getStoredName()) row.classList.remove("hidden");
  if (getStoredName()) row.classList.add("hidden");
}

// ===== AUTH GATE (FIXED) =====
async function evaluateAccess() {
  const { data } = await supabaseClient.auth.getSession();
  const session = data?.session;

  // 1) Not logged in -> show email gate
  if (!session) {
    showGate("login", "Enter your email to get a login link.");
    await updateAuthUI();
    return;
  }

  // 2) Logged in but no name saved yet -> keep them on login gate + show name box
  if (!getStoredName()) {
    showGate("login", "You‚Äôre logged in ‚Äî enter your name once to continue.");
    const row = document.getElementById("gateNameRow");
    if (row) row.classList.remove("hidden");
    await updateAuthUI();
    return;
  }

  // 3) Logged in + name, but league code not unlocked -> show code gate
  if (!isLeagueUnlocked()) {
    showGate("code", "Logged in. Now enter the league code.");
    await updateAuthUI();
    return;
  }

  // 4) All good -> unlock app
  document.getElementById("accessGate").classList.add("hidden");
  await updateAuthUI();
  showMainMenu();
}
	
async function submitLeagueCode() {
  const entered = (document.getElementById("gateLeagueCode")?.value || "").trim();
  if (!entered) return alert("Enter the league code.");

  if (entered === String(LEAGUE_CODE).trim()) {
    setLeagueUnlocked(true);
    await updateAuthUI();
    showGate("done", "Access granted. This device will stay unlocked in the future.");
} else {
    setLeagueUnlocked(false);
    alert("Incorrect league code.");
  }
}

	let league = { teams: [] };
	let season = { playerStats: {}, teamRecords: {} };
	let game = null;
	let gameHistory = [];
	let lastPlay = null;
	let pendingBattingResult = null;

	/* ================================
	‚úÖ SCHEDULE DATA (persisted)
	==================================*/
	let schedule = { days: [], teamNames: [] };
	
	function saveSchedule() {
	localStorage.setItem("wiggleSchedule", JSON.stringify(schedule));
	}
	
	function loadSchedule() {
	const data = localStorage.getItem("wiggleSchedule");
	if (data) schedule = JSON.parse(data);
	}
	
	/* ==========================================
	‚úÖ TEAM SOURCE: pulls from Configure Teams
	- uses only teams that have players
	==========================================*/
	function getValidTeamsForSchedule() {
	return league.teams.filter(t => Array.isArray(t.players) && t.players.length > 0);
	}
	
	/* ================================
	‚úÖ RANDOM HELPERS
	==================================*/
	function shuffleArray(arr) {
	for (let i = arr.length - 1; i > 0; i--) {
	const j = Math.floor(Math.random() * (i + 1));
	[arr[i], arr[j]] = [arr[j], arr[i]];
	}
	return arr;
	}
	
	/* ==========================================================
	‚úÖ BALANCED RANDOM SCHEDULE (4 teams, 6 days, 2 games/day)
	- Each pair plays exactly 2 times (double round robin)
	==========================================================*/
	function generateBalancedSchedule4(teams) {
	const names = teams.map(t => t.name);
	
	// randomize initial order (changes matchups)
	shuffleArray(names);
	
	let a = names[0], b = names[1], c = names[2], d = names[3];
	
	// 3 rounds (circle method)
	const rounds = [
	[[a, d], [b, c]],
	[[a, c], [d, b]],
	[[a, b], [c, d]]
	];
	
	// duplicate (play each other twice)
	const doubleRounds = [
	...rounds,
	...rounds.map(r => r.map(g => [g[1], g[0]])) // reverse home/away
	];
	
	// shuffle day order
	shuffleArray(doubleRounds);
	
	return {
	teamNames: teams.map(t => t.name),
	days: doubleRounds.map((games, i) => ({
	day: i + 1,
	games: games.map((g, idx) => ({
	gameNumber: idx + 1,
	away: g[0],
	home: g[1]
	}))
	}))
	};
	}

	function save() {
		localStorage.setItem("wiggleLeague", JSON.stringify(league));
	}

	async function load() {
  // load teams + players from Supabase
  const { data: teams, error: teamErr } = await supabaseClient
    .from("teams")
    .select("id, name, players:players(id, name)")
    .order("name", { ascending: true });

  if (teamErr) {
    console.log(teamErr);
    // fallback to localStorage if you want:
    const local = localStorage.getItem("wiggleLeague");
    if (local) league = JSON.parse(local);
    return;
  }

  league.teams = (teams || []).map(t => ({
    name: t.name,
    players: (t.players || []).map(p => p.name)
  }));
}


	function saveSeason() {
		localStorage.setItem("wiggleSeason", JSON.stringify(season));
	}

	function loadSeason() {
		let data = localStorage.getItem("wiggleSeason");
		if (data) {
			season = JSON.parse(data);
		}
		// ‚úÖ ensure new fields exist (older saves won't have them)
		if (!season || typeof season !== "object") season = { playerStats: {}, teamRecords: {} };
		if (!season.playerStats) season.playerStats = {};
		if (!season.teamRecords) season.teamRecords = {};
	}

	function getTeamRecord(teamName) {
		if (!season.teamRecords) season.teamRecords = {};
		if (!season.teamRecords[teamName]) {
			season.teamRecords[teamName] = { wins: 0, losses: 0 };
		}
		return season.teamRecords[teamName];
	}

	function formatTeamRecord(teamName) {
		const r = getTeamRecord(teamName);
		return `${r.wins}-${r.losses}`;
	}

	function syncTeamRecordsWithLeague() {
		// Make sure every current team has a record row
		(league.teams || []).forEach(t => getTeamRecord(t.name));
		saveSeason();
	}

	function updateScheduleForCompletedGame(teamA, teamB, resultObj) {
		if (!schedule?.days?.length) return;

		for (const day of schedule.days) {
			for (const g of day.games) {
				if (g.result) continue; // already played
				const match =
					(g.away === teamA && g.home === teamB) ||
					(g.away === teamB && g.home === teamA);
				if (!match) continue;

				g.result = resultObj;
				saveSchedule();
				return;
			}
		}
	}

	function applyGameOutcomeOnce() {
		if (!game || game._resultSaved) return;
		game._resultSaved = true;

		const t1 = game.team1?.name;
		const t2 = game.team2?.name;
		if (!t1 || !t2) return;

		const s1 = Number(game.team1Score || 0);
		const s2 = Number(game.team2Score || 0);

		// Create records if missing
		getTeamRecord(t1);
		getTeamRecord(t2);

		let resultObj;
		if (s1 === s2) {
			// tie: don't change W/L, but still mark schedule
			resultObj = { type: "tie", team1: t1, team2: t2, score1: s1, score2: s2, playedAt: Date.now() };
		} else {
			const winner = s1 > s2 ? t1 : t2;
			const loser = s1 > s2 ? t2 : t1;
			getTeamRecord(winner).wins += 1;
			getTeamRecord(loser).losses += 1;
			resultObj = {
				type: "win",
				winner,
				loser,
				winnerScore: Math.max(s1, s2),
				loserScore: Math.min(s1, s2),
				playedAt: Date.now()
			};
		}

		saveSeason();
		updateScheduleForCompletedGame(t1, t2, resultObj);
	}

	function resetSeason() {
		if (confirm("Are you sure you want to reset all season statistics? This cannot be undone!")) {
			season = { playerStats: {}, teamRecords: {} };
			saveSeason();
			showNotification("Season statistics have been reset!");
			displaySeasonStats();
		}
	}

	function getPlayerKey(teamName, playerName) {
		return teamName + "|" + playerName;
	}

	function initPlayerStats(teamName, playerName) {
		let key = getPlayerKey(teamName, playerName);
		if (!season.playerStats[key]) {
			season.playerStats[key] = {
				teamName: teamName,
				playerName: playerName,
				atBats: 0,
				hits: 0,
				singles: 0,
				doubles: 0,
				triples: 0,
				homeRuns: 0,
				walks: 0,
				strikeouts: 0,
				outs: 0,
				rbis: 0,
				pitchOuts: 0,
				pitchStrikeouts: 0,
				fieldingErrors: 0,
				inningsPitched: 0,
				runsAllowed: 0,
				earnedRunsAllowed: 0
			};
		}
	}

	function showNotification(message, duration = 2000) {
		let notif = document.getElementById("notification");
		if (notif) {
			notif.innerText = message;
			notif.classList.remove("hidden");
			setTimeout(() => {
				notif.classList.add("hidden");
			}, duration);
		}
	}

function showOutPicker() {
if (!game) return;

// If no runners on, don't show
if (!game.bases.first && !game.bases.second && !game.bases.third) {
showNotification("No runners on base", 1200);
return;
}

// Build dropdown to only show bases that actually have runners
const sel = document.getElementById("outBaseSelect");
sel.innerHTML = "";

const options = [
{ base: "first", label: "Runner on 1st" },
{ base: "second", label: "Runner on 2nd" },
{ base: "third", label: "Runner on 3rd" }
];

options.forEach(o => {
if (game.bases[o.base]) {
const opt = document.createElement("option");
opt.value = o.base;
opt.text = o.label + " (" + game.bases[o.base].player + ")";
sel.appendChild(opt);
}
});

document.getElementById("outPicker").classList.remove("hidden");
}

function cancelRunnerOut() {
document.getElementById("outPicker").classList.add("hidden");
}

function confirmRunnerOut() {
if (!game) return;

const base = document.getElementById("outBaseSelect").value;
if (!base || !game.bases[base]) {
showNotification("No runner there", 1200);
cancelRunnerOut();
return;
}

// Save for undo
gameHistory.push(saveGameState());
document.getElementById("undoButton").disabled = false;

// Remove runner + add out
const removed = game.bases[base];
game.bases[base] = null;
game.outs++;

cancelRunnerOut();
showNotification(removed.player + " thrown out!", 1200);

// If that makes 2 outs, end the half-inning using the SAME logic as normal outs
if (game.outs >= 2) {
const pitcherKey = getCurrentPitcherKey();
endHalfInning(pitcherKey, "Runner thrown out ‚Äî side over!");
updateGameScreen();
return;
}

updateGameScreen();
}


function forceRegenerateSchedule() {
const validTeams = getValidTeamsForSchedule();
if (validTeams.length !== 4) {
alert("You need exactly 4 teams with players to generate a schedule.");
return;
}
schedule = generateBalancedSchedule4(validTeams);
saveSchedule();
renderScheduleUI();
}

function renderScheduleUI() {
const container = document.getElementById("scheduleContainer");
container.innerHTML = "";

const validTeams = getValidTeamsForSchedule();

// This schedule feature is for exactly 4 teams
if (validTeams.length !== 4) {
container.innerHTML = `
<div class="card">
	<h3>Need 4 teams to build a season schedule</h3>
	<p style="color:#aaa;">
		You currently have <b>${validTeams.length}</b> team(s) with players.
		Go to Configure Teams and make sure you have exactly 4 teams, each with at least 1 player.
	</p>
</div>
`;
return;
}

const teamNames = validTeams.map(t => t.name).sort();
const scheduleNames = (schedule?.teamNames || []).slice().sort();

const needsNew =
!schedule?.days?.length ||
schedule.days.length !== 6 ||
scheduleNames.join("|") !== teamNames.join("|");

if (needsNew) {
schedule = generateBalancedSchedule4(validTeams);
saveSchedule();
}

schedule.days.forEach(dayObj => {
const dayCard = document.createElement("div");
dayCard.className = "card";

const rows = dayObj.games.map(g => {
	const awayRec = formatTeamRecord(g.away);
	const homeRec = formatTeamRecord(g.home);

	let awayTag = "";
	let homeTag = "";
	let scoreTag = "";

	if (g.result) {
		if (g.result.tie) {
			awayTag = " ü§ù T";
			homeTag = " ü§ù T";
			scoreTag = ` ‚Äî ${g.result.score1}-${g.result.score2}`;
		} else {
			awayTag = (g.result.winner === g.away) ? " ‚úÖ W" : " ‚ùå L";
			homeTag = (g.result.winner === g.home) ? " ‚úÖ W" : " ‚ùå L";
			scoreTag = ` ‚Äî ${g.result.winnerScore}-${g.result.loserScore}`;
		}
	}

	return `
<tr>
	<td>Game ${g.gameNumber}</td>
	<td>
		<b>${g.away}</b> <span style="color:#aaa;">(${awayRec})</span>${awayTag}
		&nbsp;vs&nbsp;
		<b>${g.home}</b> <span style="color:#aaa;">(${homeRec})</span>${homeTag}
		<span style="color:#aaa;">${scoreTag}</span>
	</td>
</tr>
`;
}).join("");

dayCard.innerHTML = `
<div class="section-header">Day ${dayObj.day}</div>
<table class="stats-table">
	<tr>
		<th>Game</th>
		<th>Matchup</th>
	</tr>
	${rows}
</table>
`;

container.appendChild(dayCard);
});
}

	// NAVIGATION FUNCTIONS
	function showMainMenu() {
		hideAllScreens();
		document.getElementById("mainMenu").classList.remove("hidden");
		// ‚úÖ ADD THIS to hideAllScreens()
	}

	function showTeamConfig() {
		hideAllScreens();
		document.getElementById("teamConfigScreen").classList.remove("hidden");
		update();
	}

	function showGameSetup() {
		hideAllScreens();
		
		if (league.teams.length < 2) {
			alert("You need at least 2 teams! Please configure teams first.");
			showTeamConfig();
			return;
		}

		let validTeams = league.teams.filter(t => t.players.length > 0);
		if (validTeams.length < 2) {
			alert("You need at least 2 teams with players! Please add players first.");
			showTeamConfig();
			return;
		}

		document.getElementById("gameSetupScreen").classList.remove("hidden");
		updateGameSetupSelects();
	}

	function showGame() {
		hideAllScreens();
		document.getElementById("gameScreen").classList.remove("hidden");
	}

	function showGameOver() {
		hideAllScreens();
		document.getElementById("gameOverScreen").classList.remove("hidden");
	}

	function showSeasonStats() {
		hideAllScreens();
		document.getElementById("seasonStatsScreen").classList.remove("hidden");
		displaySeasonStats();
	}

	function hideAllScreens() {
		document.getElementById("mainMenu").classList.add("hidden");
		document.getElementById("teamConfigScreen").classList.add("hidden");
		document.getElementById("gameSetupScreen").classList.add("hidden");
		document.getElementById("gameScreen").classList.add("hidden");
		document.getElementById("gameOverScreen").classList.add("hidden");
		document.getElementById("seasonStatsScreen").classList.add("hidden");
document.getElementById("scheduleScreen").classList.add("hidden");

	
document.getElementById("activeUsersScreen").classList.add("hidden");
}

	// TEAM MANAGEMENT FUNCTIONS
async function addTeam() {
  if (!(await requireLogin())) return;

  const name = document.getElementById("teamName").value.trim();
  if (!name) return;

  const { error } = await supabaseClient.from("teams").insert([{ name }]);
  if (error) return alert(error.message);

  document.getElementById("teamName").value = "";
  await load();
  update();
}
	
	async function addPlayer() {
  if (!(await requireLogin())) return;

  const teamIndex = document.getElementById("teamSelect").value;
  if (teamIndex === "" || teamIndex == null) return alert("Select a team");

  const player = document.getElementById("playerName").value.trim();
  if (!player) return;

  const teamName = league.teams[teamIndex].name;

  const { data: teamRow, error: tErr } = await supabaseClient
    .from("teams")
    .select("id")
    .eq("name", teamName)
    .single();

  if (tErr) return alert(tErr.message);

  const { error } = await supabaseClient.from("players").insert([{
    team_id: teamRow.id,
    name: player
  }]);

  if (error) return alert(error.message);

  document.getElementById("playerName").value = "";
  await load();
  update();
}

	function removeTeam(teamIndex) {
		if (confirm("Remove this team?")) {
			league.teams.splice(teamIndex, 1);
			update();
		}
	}

	function removePlayer(teamIndex, playerIndex) {
		if (confirm("Remove this player?")) {
			league.teams[teamIndex].players.splice(playerIndex, 1);
			update();
		}
	}

	function update() {
		let select = document.getElementById("teamSelect");
		select.innerHTML = "";

		if (league.teams.length === 0) {
			select.innerHTML = "<option>Add a team first</option>";
		}

		league.teams.forEach((t, i) => {
			let opt = document.createElement("option");
			opt.value = i;
			opt.text = t.name;
			select.appendChild(opt);
		});

		let list = document.getElementById("teamList");
		list.innerHTML = "";

		if (league.teams.length === 0) {
			list.innerHTML = "<p>No teams yet. Add a team above!</p>";
		}

		league.teams.forEach((team, teamIndex) => {
			let div = document.createElement("div");
			div.className = "card";

			let playersHTML = "";
			team.players.forEach((player, playerIndex) => {
				playersHTML += `<div>${player} <button onclick="removePlayer(${teamIndex},${playerIndex})">Remove</button></div>`;
			});
			if (playersHTML === "") playersHTML = "No players yet";

			div.innerHTML = `<b>${team.name}</b> <button onclick="removeTeam(${teamIndex})">Remove Team</button><br>Players:<br>${playersHTML}`;

			list.appendChild(div);
		});

		save();
	}

	// GAME SETUP FUNCTIONS
	function updateGameSetupSelects() {
		let validTeams = league.teams.filter(t => t.players.length > 0);
		
		let team1Select = document.getElementById("team1Select");
		let team2Select = document.getElementById("team2Select");
		
		team1Select.innerHTML = "";
		team2Select.innerHTML = "";

		validTeams.forEach((t, i) => {
			let opt1 = document.createElement("option");
			opt1.value = i;
			opt1.text = t.name;
			team1Select.appendChild(opt1);

			let opt2 = document.createElement("option");
			opt2.value = i;
			opt2.text = t.name;
			team2Select.appendChild(opt2);
		});

		if (validTeams.length > 1) {
			team2Select.selectedIndex = 1;
		}
	}

	function startGame() {
		let validTeams = league.teams.filter(t => t.players.length > 0);
		
		let team1Index = parseInt(document.getElementById("team1Select").value);
		let team2Index = parseInt(document.getElementById("team2Select").value);

		if (team1Index === team2Index) {
			alert("Please select two different teams!");
			return;
		}

		let t1 = validTeams[team1Index];
		let t2 = validTeams[team2Index];

		t1.players.forEach(p => initPlayerStats(t1.name, p));
		t2.players.forEach(p => initPlayerStats(t2.name, p));

		let batting = Math.random() > 0.5 ? t1 : t2;
		let fielding = batting === t1 ? t2 : t1;

		game = {
			team1: t1,
			team2: t2,
			team1Score: 0,
			team2Score: 0,
			batting: batting,
			fielding: fielding,
			outs: 0,
			inning: 1,
			halfInning: "top",
			batterIndex: 0,
			currentPitcher: null,
			bases: {
				first: null,
				second: null,
				third: null
			},
			gameStats: {},
			currentInningPitchers: {},
			halfInningRuns: 0
		};

		[...t1.players, ...t2.players].forEach(p => {
			let teamName = t1.players.includes(p) ? t1.name : t2.name;
			let key = getPlayerKey(teamName, p);
			game.gameStats[key] = {
				atBats: 0,
				hits: 0,
				singles: 0,
				doubles: 0,
				triples: 0,
				homeRuns: 0,
				walks: 0,
				strikeouts: 0,
				outs: 0,
				rbis: 0,
				pitchOuts: 0,
				pitchStrikeouts: 0,
				fieldingErrors: 0,
				inningsPitched: 0,
				runsAllowed: 0,
				earnedRunsAllowed: 0
			};
		});

		gameHistory = [];
		pendingBattingResult = null;
		document.getElementById("undoButton").disabled = true;

		showGame();
		updatePitcherSelect();
		updateGameScreen();
	}

	function endGameEarly() {
		if (confirm("End this game early? Stats will be saved up to this point.")) {
			saveGameStats();
			displayGameOver();
		}
	}

	// GAME FUNCTIONS
	function saveGameState() {
		return JSON.stringify({
			team1Score: game.team1Score,
			team2Score: game.team2Score,
			outs: game.outs,
			halfInningRuns: game.halfInningRuns,
			inning: game.inning,
			halfInning: game.halfInning,
			batterIndex: game.batterIndex,
			currentPitcher: game.currentPitcher,
			bases: {
				first: game.bases.first ? {...game.bases.first} : null,
				second: game.bases.second ? {...game.bases.second} : null,
				third: game.bases.third ? {...game.bases.third} : null
			},
			gameStats: JSON.parse(JSON.stringify(game.gameStats)),
			batting: game.batting,
			fielding: game.fielding,
			currentInningPitchers: {...game.currentInningPitchers},
			pendingBattingResult: pendingBattingResult
		});
	}

	function restoreGameState(stateString) {
		let state = JSON.parse(stateString);
		game.team1Score = state.team1Score;
		game.team2Score = state.team2Score;
		game.halfInningRuns = state.halfInningRuns ?? 0;
		game.outs = state.outs;
		game.inning = state.inning;
		game.halfInning = state.halfInning;
		game.batterIndex = state.batterIndex;
		game.currentPitcher = state.currentPitcher;
		game.bases = state.bases;
		game.gameStats = state.gameStats;
		game.batting = state.batting;
		game.fielding = state.fielding;
		game.currentInningPitchers = state.currentInningPitchers;
		pendingBattingResult = state.pendingBattingResult;
	}

	function undoLastAction() {
		if (gameHistory.length > 0) {
			let previousState = gameHistory.pop();
			restoreGameState(previousState);
			
			if (pendingBattingResult) {
				document.getElementById("battingSection").classList.add("disabled");
				document.getElementById("pitchingSection").classList.remove("disabled");
			} else {
				document.getElementById("battingSection").classList.remove("disabled");
				document.getElementById("pitchingSection").classList.add("disabled");
			}
			
			updatePitcherSelect();
			updateGameScreen();
			
			if (gameHistory.length === 0) {
				document.getElementById("undoButton").disabled = true;
			}
		}
	}

	function updatePitcherSelect() {
		let select = document.getElementById("pitcherSelect");
		select.innerHTML = "";

		game.fielding.players.forEach((player, i) => {
			let opt = document.createElement("option");
			opt.value = i;
			opt.text = player;
			select.appendChild(opt);
		});

		let halfInningKey = game.inning + "-" + game.halfInning;
		if (game.currentInningPitchers[halfInningKey] !== undefined) {
			select.selectedIndex = game.currentInningPitchers[halfInningKey];
		}

		updatePitcherDisplay();
	}

	function updatePitcherDisplay() {
		let select = document.getElementById("pitcherSelect");
		let pitcherIndex = parseInt(select.value);
		let pitcher = game.fielding.players[pitcherIndex];
		document.getElementById("pitcherText").innerText = "Pitching: " + pitcher;
	}

	function updateGameScreen() {
		document.getElementById("team1Name").innerText = game.team1.name;
		document.getElementById("team2Name").innerText = game.team2.name;
		document.getElementById("team1Score").innerText = game.team1Score;
		document.getElementById("team2Score").innerText = game.team2Score;

		let halfText = game.halfInning === "top" ? "Top" : "Bottom";
		document.getElementById("inningText").innerText =
			halfText + " of Inning " + game.inning + " | " + game.batting.name + " Batting";

		document.getElementById("outsText").innerText = "Outs: " + game.outs + "/2";

		let player = game.batting.players[game.batterIndex] || "No Player";
		document.getElementById("batterText").innerText = "Up: " + player;

		updateBasesDisplay();
	}

	function updateBasesDisplay() {
		let base1 = document.getElementById("base1");
		let base2 = document.getElementById("base2");
		let base3 = document.getElementById("base3");

		base1.className = "base first";
		base2.className = "base second";
		base3.className = "base third";
		base1.innerText = "1st";
		base2.innerText = "2nd";
		base3.innerText = "3rd";

		if (game.bases.first) {
			if (game.bases.first.type === "ghostie") {
				base1.classList.add("ghostie");
				base1.innerText = "1st\nüëª";
			} else {
				base1.classList.add("occupied");
				base1.innerText = "1st\n" + game.bases.first.player;
			}
		}

		if (game.bases.second) {
			if (game.bases.second.type === "ghostie") {
				base2.classList.add("ghostie");
				base2.innerText = "2nd\nüëª";
			} else {
				base2.classList.add("occupied");
				base2.innerText = "2nd\n" + game.bases.second.player;
			}
		}

		if (game.bases.third) {
			if (game.bases.third.type === "ghostie") {
				base3.classList.add("ghostie");
				base3.innerText = "3rd\nüëª";
			} else {
				base3.classList.add("occupied");
				base3.innerText = "3rd\n" + game.bases.third.player;
			}
		}
	}

function getCurrentPitcherKey() {
// pitcher is always from the fielding team
let pitcherIndex = parseInt(document.getElementById("pitcherSelect").value);
let pitcher = game.fielding.players[pitcherIndex];
return getPlayerKey(game.fielding.name, pitcher);
}

function manualMove(fromBase, toBase) {
// fromBase/toBase are: "first","second","third"
if (!game) return;

if (!game.bases[fromBase]) {
showNotification("No runner on " + fromBase, 1200);
return;
}
if (game.bases[toBase]) {
showNotification(toBase + " is already occupied", 1200);
return;
}

// Save for undo (optional but recommended)
gameHistory.push(saveGameState());
document.getElementById("undoButton").disabled = false;

// Move runner object exactly as-is (keeps reachedOnError flag)
game.bases[toBase] = game.bases[fromBase];
game.bases[fromBase] = null;

updateGameScreen();
}

function manualScoreFromThird() {
if (!game) return;

if (!game.bases.third) {
showNotification("No runner on 3rd", 1200);
return;
}

// Save for undo
gameHistory.push(saveGameState());
document.getElementById("undoButton").disabled = false;

const runner = game.bases.third;

// Remove runner from base
game.bases.third = null;

// Add run to batting team score
if (game.batting === game.team1) game.team1Score += 1;
else game.team2Score += 1;

// Pitcher stats (runs + earned runs)
const pitcherKey = getCurrentPitcherKey();
if (game.gameStats[pitcherKey]) {
game.gameStats[pitcherKey].runsAllowed += 1;

// earned if runner did NOT reach on error
if (!runner.reachedOnError) {
game.gameStats[pitcherKey].earnedRunsAllowed += 1;
}
}

showNotification("Run scored!", 1200);
updateGameScreen();
}

function clearBases() {
if (!game) return;

gameHistory.push(saveGameState());
document.getElementById("undoButton").disabled = false;

game.bases.first = null;
game.bases.second = null;
game.bases.third = null;

showNotification("Bases cleared", 1200);
updateGameScreen();
}

function advanceRunners(bases, currentBatter, reachedOnError = false) {
let runs = 0;
let earnedRuns = 0;
let rbis = 0;

function moveRunner(runner, n) {
if (!runner) return null;
return runner; 
}

function scoreRunner(runner) {
if (!runner) return;
runs++;
rbis++;
if (!runner.reachedOnError) earnedRuns++;
}

// Grab current base runners
let r1 = game.bases.first;
let r2 = game.bases.second;
let r3 = game.bases.third;

// Clear bases; we will rebuild them
game.bases.first = null;
game.bases.second = null;
game.bases.third = null;

// Helper: place runner on a base if not scoring
function place(baseNum, runner) {
if (!runner) return;
if (baseNum === 1) game.bases.first = runner;
if (baseNum === 2) game.bases.second = runner;
if (baseNum === 3) game.bases.third = runner;
}

// Advance existing runners:
// For each runner, compute where they end up after `bases` advancement.
// Starting base: 1 for r1, 2 for r2, 3 for r3.
function advanceExistingRunner(startBase, runner) {
if (!runner) return;

let end = startBase + bases; // e.g. start 2 + double(2) = 4 means scores
if (end >= 4) {
scoreRunner(runner);
} else {
place(end, runner);
}
}

advanceExistingRunner(3, r3);
advanceExistingRunner(2, r2);
advanceExistingRunner(1, r1);

// Put batter on correct base (unless HR)
if (bases >= 4) {
// Batter scores too
runs++;
rbis++;
if (!reachedOnError) earnedRuns++;
} else {
place(bases, { player: currentBatter, reachedOnError });
}

return { runs, earnedRuns, rbis };
}

	function checkAndConvertToGhostie(currentBatter) {
		let batterOnBase = false;
		let otherPlayerOnBase = false;

		if (game.bases.first && game.bases.first.player === currentBatter) batterOnBase = true;
		if (game.bases.second && game.bases.second.player === currentBatter) batterOnBase = true;
		if (game.bases.third && game.bases.third.player === currentBatter) batterOnBase = true;

		let partner = game.batting.players.find(p => p !== currentBatter);
		if (game.bases.first && game.bases.first.player === partner) otherPlayerOnBase = true;
		if (game.bases.second && game.bases.second.player === partner) otherPlayerOnBase = true;
		if (game.bases.third && game.bases.third.player === partner) otherPlayerOnBase = true;

		if (batterOnBase && otherPlayerOnBase) {
			if (game.bases.first && game.bases.first.player === currentBatter) {
				game.bases.first.type = "ghostie";
			}
			if (game.bases.second && game.bases.second.player === currentBatter) {
				game.bases.second.type = "ghostie";
			}
			if (game.bases.third && game.bases.third.player === currentBatter) {
				game.bases.third.type = "ghostie";
			}
		}
	}

function recordBattingResult(result) {
let currentBatter = game.batting.players[game.batterIndex];
let batterKey = getPlayerKey(game.batting.name, currentBatter);

pendingBattingResult = {
result: result,
batter: currentBatter,
batterKey: batterKey
};

// Save "who was fielding" at the moment of contact (important if inning flips)
lastPlay = {
battingTeamName: game.batting.name,
fieldingTeamName: game.fielding.name,
pitcherIndex: parseInt(document.getElementById("pitcherSelect").value),
batterKey: batterKey,
batterName: currentBatter,
result: result
};

// Automatically process as NO ERROR
recordPitchingResult("clean");
}
function showErrorPicker() {
if (!lastPlay) {
alert("No play to assign an error to yet.");
return;
}

// Find the fielding team from the last play
let fieldingTeam = league.teams.find(t => t.name === lastPlay.fieldingTeamName);
if (!fieldingTeam) {
alert("Could not find the fielding team for the last play.");
return;
}

let sel = document.getElementById("errorPlayerSelect");
sel.innerHTML = "";

fieldingTeam.players.forEach((p, i) => {
let opt = document.createElement("option");
opt.value = i;
opt.text = p;
sel.appendChild(opt);
});

document.getElementById("errorPicker").classList.remove("hidden");
}

function cancelError() {
document.getElementById("errorPicker").classList.add("hidden");
}
  
function confirmError() {
  if (!lastPlay) return;

  let idx = parseInt(document.getElementById("errorPlayerSelect").value);
  document.getElementById("errorPicker").classList.add("hidden");

  let fieldingTeam = league.teams.find(t => t.name === lastPlay.fieldingTeamName);
  let fielderName = fieldingTeam.players[idx];
  let fielderKey = getPlayerKey(fieldingTeam.name, fielderName);

  // game + season error
  if (game?.gameStats?.[fielderKey]) game.gameStats[fielderKey].fieldingErrors++;
  if (season.playerStats[fielderKey]) {
    season.playerStats[fielderKey].fieldingErrors++;
    saveSeason();
  }

  // mark batter as reachedOnError on the base they‚Äôre currently on
  const batterName = lastPlay.batterName;
  ["first", "second", "third"].forEach(base => {
    if (game.bases[base] && game.bases[base].player === batterName) {
      game.bases[base].reachedOnError = true;
    }
  });

  // undo hit credit if you want (optional)
  const batterKey = lastPlay.batterKey;
  if (game?.gameStats?.[batterKey]) {
    if (lastPlay.result === "single") {
      game.gameStats[batterKey].hits = Math.max(0, game.gameStats[batterKey].hits - 1);
      game.gameStats[batterKey].singles = Math.max(0, game.gameStats[batterKey].singles - 1);
    } else if (lastPlay.result === "double") {
      game.gameStats[batterKey].hits = Math.max(0, game.gameStats[batterKey].hits - 1);
      game.gameStats[batterKey].doubles = Math.max(0, game.gameStats[batterKey].doubles - 1);
    } else if (lastPlay.result === "triple") {
      game.gameStats[batterKey].hits = Math.max(0, game.gameStats[batterKey].hits - 1);
      game.gameStats[batterKey].triples = Math.max(0, game.gameStats[batterKey].triples - 1);
    }
  }

  showNotification("Error charged to " + fielderName, 1500);
  lastPlay = null;
  updateGameScreen();
}


function endHalfInning(pitcherKey, reasonText) {
// credit pitcher with 1 inning pitched for this completed half-inning
if (pitcherKey && game?.gameStats?.[pitcherKey]) {
game.gameStats[pitcherKey].inningsPitched += 1;
}

// clear inning state
game.bases.first = null;
game.bases.second = null;
game.bases.third = null;
game.outs = 0;
game.halfInningRuns = 0; // ‚úÖ reset for next half

// switch sides / inning
if (game.halfInning === "top") {
game.halfInning = "bottom";
let temp = game.batting;
game.batting = game.fielding;
game.fielding = temp;
game.batterIndex = 0;

updatePitcherSelect();
showNotification(reasonText || ("Side change! " + game.batting.name + " now batting."), 1500);
} else {
game.halfInning = "top";
let temp = game.batting;
game.batting = game.fielding;
game.fielding = temp;
game.batterIndex = 0;

game.inning++;

// ‚úÖ your game ends after bottom of 3rd
if (game.inning > 3) {
saveGameStats();
displayGameOver();
return;
}

updatePitcherSelect();
showNotification(reasonText || ("Inning " + game.inning + " starting! " + game.batting.name + " batting."), 1500);
}
}

function recordPitchingResult(pitchResult, errorFielderIndex = null) {
if (!pendingBattingResult) return;

const reachedOnError = (pitchResult === "error");

// Save state for undo BEFORE any changes
gameHistory.push(saveGameState());
document.getElementById("undoButton").disabled = false;

let pitcherIndex = parseInt(document.getElementById("pitcherSelect").value);
let pitcher = game.fielding.players[pitcherIndex];
let pitcherKey = getPlayerKey(game.fielding.name, pitcher);

let halfInningKey = game.inning + "-" + game.halfInning;
game.currentInningPitchers[halfInningKey] = pitcherIndex;

// Process batting result
let result = pendingBattingResult.result;
let batterKey = pendingBattingResult.batterKey;
let currentBatter = pendingBattingResult.batter;

let runs = 0;
let earnedRuns = 0;
let rbis = 0;

// AB rule: error still counts as an AB (unless it's a walk)
if (result !== "walk") {
game.gameStats[batterKey].atBats++;
}

if (result === "out" || result === "K") {
game.outs++;
if (result === "K") {
game.gameStats[batterKey].strikeouts++;
game.gameStats[pitcherKey].pitchStrikeouts++;
} else {
game.gameStats[batterKey].outs++;
}
game.gameStats[pitcherKey].pitchOuts++;

} else if (result === "single") {
let res = advanceRunners(1, currentBatter, reachedOnError);
runs = res.runs;
earnedRuns = res.earnedRuns;
rbis = res.rbis;

// ‚úÖ if reached on error, do NOT count a hit
if (!reachedOnError) {
game.gameStats[batterKey].hits++;
game.gameStats[batterKey].singles++;
}
game.gameStats[batterKey].rbis += rbis;

} else if (result === "double") {
let res = advanceRunners(2, currentBatter, reachedOnError);
runs = res.runs;
earnedRuns = res.earnedRuns;
rbis = res.rbis;

if (!reachedOnError) {
game.gameStats[batterKey].hits++;
game.gameStats[batterKey].doubles++;
}
game.gameStats[batterKey].rbis += rbis;

} else if (result === "triple") {
let res = advanceRunners(3, currentBatter, reachedOnError);
runs = res.runs;
earnedRuns = res.earnedRuns;
rbis = res.rbis;

if (!reachedOnError) {
game.gameStats[batterKey].hits++;
game.gameStats[batterKey].triples++;
}
game.gameStats[batterKey].rbis += rbis;

} else if (result === "HR") {
let res = advanceRunners(4, currentBatter, false);
runs = res.runs;
earnedRuns = res.earnedRuns;
rbis = res.rbis;

game.gameStats[batterKey].hits++;
game.gameStats[batterKey].homeRuns++;
game.gameStats[batterKey].rbis += rbis;

} else if (result === "walk") {
let res = advanceRunners(1, currentBatter, false);
runs = res.runs;
earnedRuns = res.earnedRuns;
rbis = res.rbis;

game.gameStats[batterKey].walks++;
game.gameStats[batterKey].rbis += rbis;
}

// Fielding error credit
if (pitchResult === "error") {
let fielderIdx = (errorFielderIndex !== null)
? errorFielderIndex
: parseInt(document.getElementById("pitcherSelect").value);

let fielder = game.fielding.players[fielderIdx];
let fielderKey = getPlayerKey(game.fielding.name, fielder);
game.gameStats[fielderKey].fieldingErrors++;
}

// Add runs to score
if (game.batting === game.team1) game.team1Score += runs;
else game.team2Score += runs;

// Track half inning runs for run rule
game.halfInningRuns += runs;

// Pitcher runs/earned runs
game.gameStats[pitcherKey].runsAllowed += runs;
game.gameStats[pitcherKey].earnedRunsAllowed += earnedRuns;

// Next batter
game.batterIndex = (game.batterIndex + 1) % game.batting.players.length;
checkAndConvertToGhostie(game.batting.players[game.batterIndex]);

// ‚úÖ Run rule: innings 1-2 only
if (game.inning <= 2 && game.halfInningRuns>= 6) {
	endHalfInning(pitcherKey, "Run rule reached (6). Switching sides.");
	pendingBattingResult = null;
	document.getElementById("battingSection").classList.remove("disabled");
	document.getElementById("pitchingSection").classList.add("disabled");
	updateGameScreen();
	return;
	}

	// ‚úÖ Normal end of half-inning on 2 outs
	if (game.outs >= 2) {
	endHalfInning(pitcherKey, null);
	pendingBattingResult = null;
	document.getElementById("battingSection").classList.remove("disabled");
	document.getElementById("pitchingSection").classList.add("disabled");
	updateGameScreen();
	return;
	}

	// Reset for next play
	pendingBattingResult = null;
	document.getElementById("battingSection").classList.remove("disabled");
	document.getElementById("pitchingSection").classList.add("disabled");
	updateGameScreen();
	}
	function saveGameStats() {
		for (let key in game.gameStats) {
			let gameStats = game.gameStats[key];
			let seasonStats = season.playerStats[key];

			seasonStats.atBats += gameStats.atBats;
			seasonStats.hits += gameStats.hits;
			seasonStats.singles += gameStats.singles;
			seasonStats.doubles += gameStats.doubles;
			seasonStats.triples += gameStats.triples;
			seasonStats.homeRuns += gameStats.homeRuns;
			seasonStats.walks += gameStats.walks;
			seasonStats.strikeouts += gameStats.strikeouts;
			seasonStats.outs += gameStats.outs;
			seasonStats.rbis += gameStats.rbis;
			seasonStats.pitchOuts += gameStats.pitchOuts;
			seasonStats.pitchStrikeouts += gameStats.pitchStrikeouts;
			seasonStats.fieldingErrors += gameStats.fieldingErrors;
			seasonStats.inningsPitched += gameStats.inningsPitched;
			seasonStats.runsAllowed += gameStats.runsAllowed;
			seasonStats.earnedRunsAllowed += gameStats.earnedRunsAllowed;
		}

		applyGameOutcomeOnce();
		saveSeason();
	}

	function displayGameOver() {
		showGameOver();

		let winner = game.team1Score > game.team2Score ? game.team1.name : 
		             game.team2Score > game.team1Score ? game.team2.name : null;

		let banner = document.getElementById("winnerBanner");
		if (winner) {
			banner.innerText = "üèÜ " + winner + " Wins! üèÜ";
			banner.style.background = "#4a4";
		} else {
			banner.innerText = "It's a Tie!";
			banner.style.background = "#888";
		}

		document.getElementById("finalTeam1Name").innerText = game.team1.name;
		document.getElementById("finalTeam2Name").innerText = game.team2.name;
		document.getElementById("finalTeam1Score").innerText = game.team1Score;
		document.getElementById("finalTeam2Score").innerText = game.team2Score;

		let container = document.getElementById("statsContainer");
		container.innerHTML = "";

		let team1BattingCard = document.createElement("div");
		team1BattingCard.className = "card";
		team1BattingCard.innerHTML = `<h3>${game.team1.name} - Batting Statistics</h3>`;
		let team1BattingTable = createBattingStatsTable(game.team1, false);
		team1BattingCard.appendChild(team1BattingTable);
		container.appendChild(team1BattingCard);

		let team1PitchingCard = document.createElement("div");
		team1PitchingCard.className = "card";
		team1PitchingCard.innerHTML = `<h3>${game.team1.name} - Pitching Statistics</h3>`;
		let team1PitchingTable = createPitchingStatsTable(game.team1, false);
		team1PitchingCard.appendChild(team1PitchingTable);
		container.appendChild(team1PitchingCard);

		let team2BattingCard = document.createElement("div");
		team2BattingCard.className = "card";
		team2BattingCard.innerHTML = `<h3>${game.team2.name} - Batting Statistics</h3>`;
		let team2BattingTable = createBattingStatsTable(game.team2, false);
		team2BattingCard.appendChild(team2BattingTable);
		container.appendChild(team2BattingCard);

		let team2PitchingCard = document.createElement("div");
		team2PitchingCard.className = "card";
		team2PitchingCard.innerHTML = `<h3>${game.team2.name} - Pitching Statistics</h3>`;
		let team2PitchingTable = createPitchingStatsTable(game.team2, false);
		team2PitchingCard.appendChild(team2PitchingTable);
		container.appendChild(team2PitchingCard);
	}

	function createBattingStatsTable(team, isSeason) {
		let table = document.createElement("table");
		table.className = "stats-table";

		let header = `
			<tr>
				<th>Player</th>
				<th>AVG</th>
				<th>H</th>
				<th>1B</th>
				<th>2B</th>
				<th>3B</th>
				<th>HR</th>
				<th>RBI</th>
				${isSeason ? '<th>AB</th>' : ''}
			</tr>
		`;

		let rows = "";
		team.players.forEach(player => {
			let key = getPlayerKey(team.name, player);
			let stats = isSeason ? season.playerStats[key] : game.gameStats[key];
			let avg = stats.atBats > 0 ? (stats.hits / stats.atBats).toFixed(3) : ".000";

			rows += `
				<tr>
					<td>${player}</td>
					<td>${avg}</td>
					<td>${stats.hits}</td>
					<td>${stats.singles}</td>
					<td>${stats.doubles}</td>
					<td>${stats.triples}</td>
					<td>${stats.homeRuns}</td>
					<td>${stats.rbis}</td>
					${isSeason ? `<td>${stats.atBats}</td>` : ''}
				</tr>
			`;
		});

		table.innerHTML = header + rows;
		return table;
	}

	function createPitchingStatsTable(team, isSeason) {
		let table = document.createElement("table");
		table.className = "stats-table";

		let header = `
		<tr>
			<th>Player</th>
			<th>IP</th>
			<th>K's</th>
			<th>Outs</th>
			<th>R</th>
			<th>ER</th>
			<th>ERA</th>
			<th>Errors</th>
		</tr>
		`;

		let rows = "";
		team.players.forEach(player => {
			let key = getPlayerKey(team.name, player);
			let stats = isSeason ? season.playerStats[key] : game.gameStats[key];

let era = stats.inningsPitched > 0
? ((stats.earnedRunsAllowed / stats.inningsPitched) * 3).toFixed(2)
: "-";

		rows += `
		<tr>
			<td>${player}</td>
			<td>${stats.inningsPitched.toFixed(1)}</td>
			<td>${stats.pitchStrikeouts}</td>
			<td>${stats.pitchOuts}</td>
			<td>${stats.runsAllowed}</td>
			<td>${stats.earnedRunsAllowed}</td>
			<td>${era}</td>
			<td>${stats.fieldingErrors}</td>
		</tr>
		`;
		});

		table.innerHTML = header + rows;
		return table;
	}

	function displaySeasonStats() {
		let container = document.getElementById("seasonStatsContainer");
		container.innerHTML = "";

		if (Object.keys(season.playerStats).length === 0) {
			container.innerHTML = "<div class='card'><p>No season statistics yet. Play some games!</p></div>";
			return;
		}

		let teamGroups = {};
		league.teams.forEach(team => {
			teamGroups[team.name] = [];
			team.players.forEach(player => {
				let key = getPlayerKey(team.name, player);
				if (season.playerStats[key]) {
					teamGroups[team.name].push(player);
				}
			});
		});

		for (let teamName in teamGroups) {
			if (teamGroups[teamName].length === 0) continue;

			let team = league.teams.find(t => t.name === teamName);
			
			let battingCard = document.createElement("div");
			battingCard.className = "card";
			battingCard.innerHTML = `<h3>${teamName} (${formatTeamRecord(teamName)}) - Season Batting Statistics</h3>`;
			let battingTable = createBattingStatsTable(team, true);
			battingCard.appendChild(battingTable);
			container.appendChild(battingCard);

			let pitchingCard = document.createElement("div");
			pitchingCard.className = "card";
			pitchingCard.innerHTML = `<h3>${teamName} (${formatTeamRecord(teamName)}) - Season Pitching Statistics</h3>`;
			let pitchingTable = createPitchingStatsTable(team, true);
			pitchingCard.appendChild(pitchingTable);
			container.appendChild(pitchingCard);
		}
	}

	function showSchedule() {
	  hideAllScreens();
	  document.getElementById("scheduleScreen").classList.remove("hidden");
	  renderScheduleUI();
	}
	
	async function sendLoginLink() {
  // main menu fallback (kept for convenience)
  const email = (document.getElementById("loginEmail")?.value || "").trim();
  if (!email) return alert("Enter an email");
  if (!validateEmailBasic(email)) return alert("Enter a valid email");

  // store email
  setStoredEmail(email);

  const { error } = await supabaseClient.auth.signInWithOtp({
    email,
    options: {
      emailRedirectTo: "https://tingbing.github.io/wiffle-ball-league/"
    }
  });

  if (error) return alert(error.message);
  alert("Check your email for the login link!");
}

async function sendLoginLinkFromGate() {
  const email = (document.getElementById("gateLoginEmail")?.value || "").trim();
  const name = (document.getElementById("gateNameInput")?.value || "").trim();

  if (!email) return alert("Enter an email");
  if (!validateEmailBasic(email)) return alert("Enter a valid email");

  // After user enters their email, require name (your request)
  if (!getStoredName() && !name) {
    document.getElementById("gateNameRow").classList.remove("hidden");
    return alert("Please enter your name.");
  }

  if (name) setStoredName(name);
  setStoredEmail(email);

  const { error } = await supabaseClient.auth.signInWithOtp({
    email,
    options: { emailRedirectTo: "https://tingbing.github.io/wiffle-ball-league/" }
  });

  if (error) return alert(error.message);
  alert("Check your email for the login link!");
}



async function logout() {
  await stopPresence();
  await supabaseClient.auth.signOut();
  setLeagueUnlocked(false);
  alert("Logged out");
  // lock back down
  await evaluateAccess();
}

	async function supabaseConnectionTest() {
  console.log("Supabase URL:", SUPABASE_URL);

  // This just checks that Supabase responds (no tables required)
  const { data, error } = await supabaseClient.from("_dummy_does_not_exist").select("*").limit(1);

  // If connected, you'll usually get an error about the table not existing (THAT'S OK)
  if (error) {
    console.log("Supabase responded ‚úÖ (expected error):", error.message);
    alert("Supabase connected ‚úÖ (it responded). Next: add real tables + save/load code.");
  } else {
    console.log("Unexpected data:", data);
    alert("Supabase connected ‚úÖ");
  }
}

	async function requireLogin() {
  const { data } = await supabaseClient.auth.getSession();
  if (!data.session) {
    alert("You must be logged in. Use your email to get a login link.");
    showGate("login");
    return false;
  }
  if (!getStoredName()) {
    alert("Please enter your name to continue.");
    showGate("login");
    document.getElementById("gateNameRow").classList.remove("hidden");
    return false;
  }
  if (!isLeagueUnlocked()) {
    alert("League code required to use the app.");
    showGate("code");
    return false;
  }
  return true;
}

function showEmailScreen() {
  hideAllScreens();
  document.getElementById("emailScreen").classList.remove("hidden");
}

function showLeagueCodeScreen() {
  hideAllScreens();
  document.getElementById("leagueCodeScreen").classList.remove("hidden");
}


// Initialize
// Initialize

(async function init() {
  // Gate email typing -> show name box after email entered
  const gateEmailEl = document.getElementById("gateLoginEmail");
  if (gateEmailEl) {
    gateEmailEl.addEventListener("input", (e) =>
      maybeShowNameBox((e.target.value || "").trim())
    );
  }

  // Keep main menu email typing behavior too (optional)
  const mainEmailEl = document.getElementById("loginEmail");
  if (mainEmailEl) {
    mainEmailEl.addEventListener("change", (e) => {
      const email = (e.target.value || "").trim();
      if (email) setStoredEmail(email);
      if (email && !getStoredName()) showGate("login");
    });
  }

  // React to login/logout automatically
  supabaseClient.auth.onAuthStateChange(async (_event, _session) => {
    await evaluateAccess();
    await updateAuthUI();
  });

  await load(); // pulls teams from Supabase
  loadSchedule();
  loadSeason();
  syncTeamRecordsWithLeague();
  saveSeason();
  update();

  // ‚úÖ THIS IS THE KEY: run the gate check ON PAGE LOAD (including magic-link redirects)
  await evaluateAccess();
  await updateAuthUI();
})();
	
</script>

</body>
</html>
